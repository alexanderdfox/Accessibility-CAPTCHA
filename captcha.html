<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Accessible CAPTCHA Demo</title>
<link rel="stylesheet" href="accessibility.css">
<style>
  /* CAPTCHA-specific styles only */
  :root{
	--bg:#f6f8fa; --card:#fff; --accent:#2563eb; --muted:#6b7280; --error:#dc2626;
	--focus-ring: 0 0 0 3px rgba(37,99,235,0.5);
	--focus-ring-dark: 0 0 0 3px rgba(37,99,235,0.8);
	font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  *:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
  *:focus{outline:3px solid var(--accent);outline-offset:2px}
  .js-focus-visible *:focus:not(.focus-visible){outline:none}
  .skip-link{position:absolute;top:-40px;left:0;background:var(--accent);color:#fff;padding:8px 16px;text-decoration:none;border-radius:4px;z-index:1000}
  .skip-link:focus{top:8px}
  body{margin:0;background:linear-gradient(180deg,#eef2ff, var(--bg));min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px;position:relative}
  .card{width:100%;max-width:820px;background:var(--card);border-radius:12px;box-shadow:0 8px 30px rgba(16,24,40,.08);padding:24px}
  h1{margin:0 0 8px;font-size:24px;font-weight:700;color:#1f2937}
  p.lead{margin:0 0 18px;color:#374151;line-height:1.6}
  .modes{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:18px}
  button.mode{border:2px solid #e6e9ef;background:transparent;padding:12px 16px;border-radius:8px;cursor:pointer;font-size:14px;font-weight:500;transition:all 0.2s;min-height:44px}
  button.mode:hover{background:#f9fafb;border-color:#d1d5db}
  button.mode:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
  button.mode[aria-pressed="true"]{border-color:var(--accent);background:#eff6ff;box-shadow:0 4px 18px rgba(37,99,235,.12);color:var(--accent)}
  .actions{display:flex;gap:10px;align-items:center;margin-bottom:18px;flex-wrap:wrap}
  .status{padding:12px;border-radius:8px;background:#f8fafc;border:1px solid #eef2ff;color:#064e3b;min-height:20px}
  .hidden{display:none !important}
  label{display:block;margin-bottom:8px;font-weight:600;color:#1f2937;font-size:14px}
  .text-challenge{display:grid;gap:12px;margin-top:12px}
  input[type="text"]{padding:12px;border-radius:8px;border:2px solid #e6e9ef;font-size:16px;min-height:44px;width:100%;box-sizing:border-box}
  input[type="text"]:focus{border-color:var(--accent);outline:none}
  input[type="text"].error{border-color:var(--error)}
  .error-message{color:var(--error);font-size:14px;margin-top:4px;display:block}
  .note{font-size:14px;color:#4b5563;line-height:1.5}
  .footer{margin-top:24px;font-size:13px;color:#6b7280;line-height:1.6}
  .success{background:#ecfdf5;border:2px solid #bbf7d0;color:#065f46;padding:16px;border-radius:8px}
  .danger{background:#fff1f2;border:2px solid #ffd7de;color:#7f1d1d;padding:16px;border-radius:8px}
  small.kv{color:#6b7280;display:block;margin-top:8px;font-size:13px}
  button{min-height:44px;font-size:14px;font-weight:500;cursor:pointer;transition:all 0.2s}
  button:disabled{opacity:0.6;cursor:not-allowed}
  button.primary{background:var(--accent);color:#fff;border:0;padding:12px 20px;border-radius:8px}
  button.primary:hover:not(:disabled){background:#1d4ed8}
  button.primary:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
  button.secondary{padding:12px 20px;border-radius:8px;border:2px solid #e6e9ef;background:transparent;color:#374151}
  button.secondary:hover{background:#f9fafb;border-color:#d1d5db}
  button.secondary:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
  button[role="switch"]{outline:none}
  button[role="switch"]:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
  button[role="switch"][aria-checked="false"]{background:#9ca3af}
  button[role="switch"][aria-checked="false"] span{transform:translateX(0) !important}
  @media (prefers-reduced-motion: reduce) {
	*{transition:none !important;animation:none !important}
	button[role="switch"] span{transition:none !important}
  }
  @supports not (display: grid) {
	.text-challenge{display:block}
  }
  @supports not (--css: variables) {
	:root{--bg:#f6f8fa;--card:#fff;--accent:#2563eb;--muted:#6b7280;--error:#dc2626}
  }
  @media (max-width: 640px) {
	.card{padding:16px}
	.modes{flex-direction:column}
	button.mode{width:100%}
	.actions{flex-direction:column}
	.actions button{width:100%}
  }
  /* High contrast mode overrides for CAPTCHA-specific elements */
  body.high-contrast .card{background:#000 !important;border:3px solid #fff !important;color:#fff !important}
  body.high-contrast h1,body.high-contrast h2,body.high-contrast h3,body.high-contrast h4{color:#fff !important}
  body.high-contrast p,body.high-contrast .lead{color:#fff !important}
  body.high-contrast label{color:#fff !important}
  body.high-contrast .note{color:#fff !important}
  body.high-contrast .footer{color:#fff !important}
  body.high-contrast small,body.high-contrast .kv{color:#fff !important}
  body.high-contrast .status{background:#000 !important;border:3px solid #fff !important;color:#fff !important}
  body.high-contrast button.mode{background:#000 !important;color:#fff !important;border:3px solid #fff !important}
  body.high-contrast button.mode[aria-pressed="true"]{background:#fff !important;color:#000 !important;border:3px solid #fff !important}
  body.high-contrast button.primary{background:#fff !important;color:#000 !important;border:3px solid #fff !important}
  body.high-contrast button.secondary{background:#000 !important;color:#fff !important;border:3px solid #fff !important}
  body.high-contrast button[role="switch"]{background:#000 !important;border:3px solid #fff !important}
  body.high-contrast button[role="switch"][aria-checked="true"]{background:#fff !important}
  body.high-contrast button[role="switch"][aria-checked="false"]{background:#000 !important}
  body.high-contrast button[role="switch"] span{background:#fff !important}
  body.high-contrast button:disabled{opacity:0.5 !important;color:#888 !important}
  body.high-contrast input{border:3px solid #fff !important;background:#000 !important;color:#fff !important}
  body.high-contrast input::placeholder{color:#888 !important}
  body.high-contrast .success{background:#000 !important;border:3px solid #0f0 !important;color:#0f0 !important}
  body.high-contrast .success *{color:#0f0 !important}
  body.high-contrast .danger{background:#000 !important;border:3px solid #f00 !important;color:#f00 !important}
  body.high-contrast .danger *{color:#f00 !important}
  body.high-contrast .error-message{color:#f00 !important}
  body.high-contrast{background:#000 !important;background-image:none !important}
</style>
<script src="accessibility.js"></script>
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>
  
  <!-- Accessibility panel will be auto-injected by accessibility.js -->
		
  <main class="card" id="main-content" role="main" aria-labelledby="title">
	<h1 id="title">Accessible CAPTCHA Demo</h1>
	<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:18px;flex-wrap:wrap;gap:12px">
	  <p class="lead" style="margin:0;flex:1;min-width:250px">Choose an accessibility mode (or let the invisible check run). This demo shows client-side behavior scoring, a WebAuthn fallback (simulated here), and a screen-reader-friendly question fallback.</p>
	  <div style="display:flex;align-items:center;gap:8px">
		<label for="audioToggle" style="font-size:14px;font-weight:500;color:#374151;cursor:pointer;display:flex;align-items:center;gap:6px">
		  <span>ðŸ”Š</span>
		  <span>Audio alerts</span>
		</label>
		<button id="audioToggle" role="switch" aria-checked="true" aria-labelledby="audioToggleLabel" style="width:50px;height:28px;border-radius:14px;border:2px solid #e6e9ef;background:#2563eb;position:relative;cursor:pointer;transition:background 0.2s">
		  <span style="position:absolute;left:2px;top:2px;width:22px;height:22px;border-radius:50%;background:#fff;transition:transform 0.2s;transform:translateX(22px)"></span>
		</button>
		<span id="audioToggleLabel" class="sr-only">Toggle audio alerts for accessibility</span>
	  </div>
	</div>

	<h2 id="mode-group-label" style="font-size:16px;font-weight:600;margin-bottom:8px;color:#1f2937">Choose verification mode:</h2>
	<div class="modes" role="radiogroup" aria-labelledby="mode-group-label">
	  <button class="mode" id="mode-auto" aria-pressed="true" aria-describedby="mode-auto-desc" data-mode="auto">
		Automatic (invisible)
		<span class="sr-only"> - Selected</span>
	  </button>
	  <span id="mode-auto-desc" class="sr-only">Invisible behavioral check that runs automatically</span>
	  
	  <button class="mode" id="mode-passkey" aria-pressed="false" aria-describedby="mode-passkey-desc" data-mode="passkey">
		Passkey / WebAuthn
	  </button>
	  <span id="mode-passkey-desc" class="sr-only">Use a passkey or WebAuthn for verification</span>
	  
	  <button class="mode" id="mode-text" aria-pressed="false" aria-describedby="mode-text-desc" data-mode="text">
		Text question
	  </button>
	  <span id="mode-text-desc" class="sr-only">Answer a simple text-based question</span>
	  
	  <button class="mode" id="mode-keyboard" aria-pressed="false" aria-describedby="mode-keyboard-desc" data-mode="keyboard">
		Keyboard-only
	  </button>
	  <span id="mode-keyboard-desc" class="sr-only">Keyboard accessible text question mode</span>
	</div>

	<div class="actions">
	  <button id="startBtn" class="primary" aria-describedby="status">
		Start verification
	  </button>
	  <div id="status" class="status" role="status" aria-live="polite" aria-atomic="true">Not started</div>
	</div>

	<section id="textChallenge" class="text-challenge hidden" aria-hidden="true" aria-labelledby="textChallengeTitle">
	  <h2 id="textChallengeTitle" class="sr-only">Text Challenge</h2>
	  <label for="textAnswer" id="textLabel">
		Accessibility question
		<span class="sr-only">, required</span>
	  </label>
	  <div id="questionText" class="note" role="text" aria-label="Question">Question goes here</div>
	  <input 
		id="textAnswer" 
		type="text" 
		aria-labelledby="textLabel questionText" 
		aria-required="true"
		aria-invalid="false"
		aria-describedby="textError textHint"
		autocomplete="off"
		spellcheck="false"
	  />
	  <span id="textError" class="error-message hidden" role="alert" aria-live="polite"></span>
	  <div id="textHint" class="sr-only">This question is screen-reader friendly and avoids images or audio.</div>
	  <div style="display:flex;gap:8px;margin-top:8px">
		<button id="submitText" class="primary">Submit</button>
		<button id="cancelText" class="secondary">Cancel</button>
	  </div>
	  <small class="kv">This question is screen-reader friendly and avoids images/audio.</small>
	</section>

	<section id="passkeyInfo" class="hidden" aria-hidden="true" aria-labelledby="passkeyTitle" style="margin-top:12px">
	  <h2 id="passkeyTitle" class="sr-only">Passkey Verification</h2>
	  <div class="note" id="passkeyDescription">Passkey / WebAuthn is available on many modern devices. Create a passkey to use for verification.</div>
	  <div id="passkeyStatus" class="note" style="margin-top:8px;display:none"></div>
	  <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
		<button id="createPasskey" class="primary" style="background:#0ea5a4">Create passkey</button>
		<button id="authenticatePasskey" class="primary" style="background:#0ea5a4;display:none">Authenticate with passkey</button>
		<button id="clearPasskey" class="secondary" style="display:none">Clear stored passkey</button>
	  </div>
	</section>

	<div id="resultBox" class="hidden" aria-hidden="true" style="margin-top:18px" role="region" aria-live="polite" aria-atomic="true"></div>

	<footer class="footer" role="contentinfo">
	  <strong>Notes:</strong> This demo focuses on accessibility flows. In production, validate all proofs server-side (behavior tokens, WebAuthn assertions, passkey registration).
	</footer>

	<div id="lr" class="sr-only" aria-live="assertive" aria-atomic="true"></div>
  </main>

<script>
/*
  Accessible CAPTCHA demo
  - Invisible behavioral scoring (client-side demo)
  - WebAuthn / passkey flow (simulated here; real must use server challenges + HTTPS)
  - Simple text question (screen-reader friendly)
  - Expose hooks where server verification should be performed
*/

/* ---------- Helper functions using A11yPlugin API ---------- */

// Use A11yPlugin API for screen reader announcements
function announceToScreenReader(message, priority = 'polite') {
  if (window.A11yPlugin && window.A11yPlugin.announceToScreenReader) {
	window.A11yPlugin.announceToScreenReader(message, priority);
  } else {
	// Fallback if plugin not loaded yet
	const lr = document.getElementById('lr');
	if (lr) {
	  lr.setAttribute('aria-live', priority);
	  lr.textContent = message;
	  setTimeout(() => { lr.textContent = ''; }, 1000);
	}
  }
}

// Use A11yPlugin API for audio alerts
function playSuccessSound() {
  if (window.A11yPlugin && window.A11yPlugin.playSuccessSound) {
	window.A11yPlugin.playSuccessSound();
  }
}

function playErrorSound() {
  if (window.A11yPlugin && window.A11yPlugin.playErrorSound) {
	window.A11yPlugin.playErrorSound();
  }
}

function playInfoSound() {
  if (window.A11yPlugin && window.A11yPlugin.playInfoSound) {
	window.A11yPlugin.playInfoSound();
  }
}

function playModeChangeSound() {
  // Use info sound for mode changes
  playInfoSound();
}

// Toggle audio alerts using plugin API
function toggleAudioAlerts() {
  if (window.A11yPlugin && window.A11yPlugin.toggleAudioAlerts) {
	window.A11yPlugin.toggleAudioAlerts();
	// Update local toggle button state
	const toggle = document.getElementById('audioToggle');
	if (toggle) {
	  const saved = window.safeStorage ? window.safeStorage.getItem('audioAlertsEnabled') : null;
	  const enabled = saved !== null ? saved === 'true' : true;
	  toggle.setAttribute('aria-checked', enabled.toString());
	}
  }
}

// Load audio preference
function loadAudioPreference() {
  if (window.safeStorage) {
	const saved = window.safeStorage.getItem('audioAlertsEnabled');
	if (saved !== null) {
	  const toggle = document.getElementById('audioToggle');
	  if (toggle) {
		toggle.setAttribute('aria-checked', saved);
	  }
	}
  }
}

/* ---------- Browser Compatibility Layer ---------- */
(function() {
  'use strict';
  
  // Detect browser
  const browserInfo = {
	name: 'unknown',
	version: 0,
	isIE: false,
	isEdge: false,
	isChrome: false,
	isFirefox: false,
	isSafari: false,
	isOpera: false,
	supportsWebAuthn: false,
	supportsAudioContext: false,
	supportsSpeechRecognition: false,
	supportsLocalStorage: false,
	supportsMediaQueries: false
  };
  
  // Browser detection
  const ua = navigator.userAgent.toLowerCase();
  if (ua.indexOf('msie') !== -1 || ua.indexOf('trident') !== -1) {
	browserInfo.name = 'IE';
	browserInfo.isIE = true;
	browserInfo.version = parseFloat(ua.match(/(?:msie |rv:)(\d+(\.\d+)?)/)[1]);
  } else if (ua.indexOf('edg') !== -1 || ua.indexOf('edge') !== -1) {
	browserInfo.name = 'Edge';
	browserInfo.isEdge = true;
	browserInfo.version = parseFloat(ua.match(/edg?\/(\d+)/)[1]);
  } else if (ua.indexOf('chrome') !== -1 && ua.indexOf('edg') === -1) {
	browserInfo.name = 'Chrome';
	browserInfo.isChrome = true;
	browserInfo.version = parseFloat(ua.match(/chrome\/(\d+)/)[1]);
  } else if (ua.indexOf('firefox') !== -1) {
	browserInfo.name = 'Firefox';
	browserInfo.isFirefox = true;
	browserInfo.version = parseFloat(ua.match(/firefox\/(\d+)/)[1]);
  } else if (ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1) {
	browserInfo.name = 'Safari';
	browserInfo.isSafari = true;
	browserInfo.version = parseFloat(ua.match(/version\/(\d+)/)?.[1] || '0');
  } else if (ua.indexOf('opr') !== -1 || ua.indexOf('opera') !== -1) {
	browserInfo.name = 'Opera';
	browserInfo.isOpera = true;
	browserInfo.version = parseFloat(ua.match(/(?:opr|opera)\/(\d+)/)[1]);
  }
  
  // Feature detection
  browserInfo.supportsWebAuthn = !!(window.PublicKeyCredential && navigator.credentials);
  browserInfo.supportsAudioContext = !!(window.AudioContext || window.webkitAudioContext);
  browserInfo.supportsSpeechRecognition = !!(window.SpeechRecognition || window.webkitSpeechRecognition);
  browserInfo.supportsMediaQueries = !!(window.matchMedia);
  
  // Use safeStorage from plugin if available, otherwise create fallback
  if (!window.safeStorage) {
	// localStorage with fallback
	try {
	  localStorage.setItem('__test__', '1');
	  localStorage.removeItem('__test__');
	  browserInfo.supportsLocalStorage = true;
	} catch (e) {
	  browserInfo.supportsLocalStorage = false;
	}
	
	// Safe localStorage wrapper with fallback
	window.safeStorage = {
	  setItem: function(key, value) {
		try {
		  if (browserInfo.supportsLocalStorage) {
			localStorage.setItem(key, value);
		  } else {
			try {
			  sessionStorage.setItem(key, value);
			} catch (e) {
			  window._memoryStorage = window._memoryStorage || {};
			  window._memoryStorage[key] = value;
			}
		  }
		} catch (e) {
		  console.warn('Storage not available:', e);
		}
	  },
	  getItem: function(key) {
		try {
		  if (browserInfo.supportsLocalStorage) {
			return localStorage.getItem(key);
		  } else {
			try {
			  return sessionStorage.getItem(key);
			} catch (e) {
			  return window._memoryStorage && window._memoryStorage[key] || null;
			}
		  }
		} catch (e) {
		  return null;
		}
	  },
	  removeItem: function(key) {
		try {
		  if (browserInfo.supportsLocalStorage) {
			localStorage.removeItem(key);
		  } else {
			try {
			  sessionStorage.removeItem(key);
			} catch (e) {
			  if (window._memoryStorage) {
				delete window._memoryStorage[key];
			  }
			}
		  }
		} catch (e) {
		  console.warn('Storage removal failed:', e);
		}
	  }
	};
  }
  
  // Media query polyfill for older browsers
  if (!window.matchMedia) {
	window.matchMedia = function(query) {
	  return {
		matches: false,
		media: query,
		onchange: null,
		addListener: function() {},
		removeListener: function() {},
		addEventListener: function() {},
		removeEventListener: function() {},
		dispatchEvent: function() { return false; }
	  };
	};
  }
  
  // Array.from polyfill for IE
  if (!Array.from) {
	Array.from = function(arrayLike) {
	  return Array.prototype.slice.call(arrayLike);
	};
  }
  
  // Object.assign polyfill for IE
  if (typeof Object.assign !== 'function') {
	Object.assign = function(target) {
	  if (target == null) {
		throw new TypeError('Cannot convert undefined or null to object');
	  }
	  const to = Object(target);
	  for (let index = 1; index < arguments.length; index++) {
		const nextSource = arguments[index];
		if (nextSource != null) {
		  for (const nextKey in nextSource) {
			if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
			  to[nextKey] = nextSource[nextKey];
			}
		  }
		}
	  }
	  return to;
	};
  }
  
  // Set polyfill for older browsers
  if (typeof Set === 'undefined') {
	window.Set = function() {
	  this.items = {};
	  this.add = function(value) {
		this.items[value] = true;
		return this;
	  };
	  this.has = function(value) {
		return this.items.hasOwnProperty(value);
	  };
	  this.delete = function(value) {
		delete this.items[value];
		return this;
	  };
	  this.size = Object.keys(this.items).length;
	};
	Object.defineProperty(window.Set.prototype, 'size', {
	  get: function() {
		return Object.keys(this.items).length;
	  }
	});
  }
  
  // Export for global use
  window.browserInfo = browserInfo;
  
  // Show browser compatibility warning if needed
  if (browserInfo.isIE && browserInfo.version < 11) {
	const warning = document.createElement('div');
	warning.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#ff0000;color:#fff;padding:10px;text-align:center;z-index:99999;';
	warning.textContent = 'Your browser is not supported. Please use a modern browser like Chrome, Firefox, Safari, or Edge.';
	document.body.appendChild(warning);
  }
})();

/* ---------- Configuration ---------- */
const BEHAVIOR_MIN_SCORE = 0.6; // threshold for demo "invisible pass"
const BEHAVIOR_RUN_SECONDS = 5; // how long to collect events before evaluating

/* ---------- Mode selection UI ---------- */
const modeButtons = document.querySelectorAll('.mode');
let selectedMode = 'auto';
modeButtons.forEach(btn=>{
  btn.addEventListener('click', () => {
	modeButtons.forEach(b=>{
	  b.setAttribute('aria-pressed','false');
	  const srText = b.querySelector('.sr-only');
	  if(srText && srText.textContent.includes('Selected')) {
		srText.textContent = '';
	  }
	});
	btn.setAttribute('aria-pressed','true');
	selectedMode = btn.dataset.mode;
	
	// Update screen reader text
	const srText = btn.querySelector('.sr-only');
	if(srText) {
	  srText.textContent = ' - Selected';
	}
	
	updateModeUI();
	announceToScreenReader(`Mode changed to ${btn.textContent.trim()}`);
	playModeChangeSound();
  });
});

function updateModeUI(){
  // show/hide mode-specific UI
  const textChallenge = document.getElementById('textChallenge');
  const passkeyInfo = document.getElementById('passkeyInfo');
  
  const isTextMode = selectedMode === 'text' || selectedMode === 'keyboard';
  textChallenge.classList.toggle('hidden', !isTextMode);
  textChallenge.setAttribute('aria-hidden', isTextMode ? 'false' : 'true');
  
  passkeyInfo.classList.toggle('hidden', selectedMode !== 'passkey');
  passkeyInfo.setAttribute('aria-hidden', selectedMode !== 'passkey' ? 'true' : 'false');
}

/* ---------- Behavior scoring ---------- */
let behaviorState = {
  mouseMoves:0,
  pointerTypeSet: new Set(),
  keyPresses:0,
  focusEvents:0,
  timestamps:[],
};
let behaviorTimer=null;

function resetBehavior(){
  behaviorState = {mouseMoves:0, pointerTypeSet:new Set(), keyPresses:0, focusEvents:0, timestamps:[]};
  if(behaviorTimer) { clearTimeout(behaviorTimer); behaviorTimer=null; }
}

function collectBehaviorEvents(){
  resetBehavior();
  const onMouse = (e)=> {
	behaviorState.mouseMoves++;
	if(e.pointerType) behaviorState.pointerTypeSet.add(e.pointerType);
	behaviorState.timestamps.push(Date.now());
  };
  const onKey = ()=> { behaviorState.keyPresses++; behaviorState.timestamps.push(Date.now()); };
  const onFocus = ()=> { behaviorState.focusEvents++; behaviorState.timestamps.push(Date.now()); };

  window.addEventListener('mousemove', onMouse);
  window.addEventListener('pointermove', onMouse);
  window.addEventListener('keydown', onKey);
  window.addEventListener('focusin', onFocus);

  behaviorTimer = setTimeout(()=> {
	window.removeEventListener('mousemove', onMouse);
	window.removeEventListener('pointermove', onMouse);
	window.removeEventListener('keydown', onKey);
	window.removeEventListener('focusin', onFocus);
	const score = evaluateBehavior(behaviorState);
	onBehaviorEvaluated(score);
  }, BEHAVIOR_RUN_SECONDS * 1000);
}

function evaluateBehavior(state){
  // Simple heuristic combining multiple signals â€” production systems should be more sophisticated
  // Mouse activity
  const mouseScore = Math.min(1, state.mouseMoves / 20);
  // Pointer diversity (touch/mouse) increases score if present
  const pointerScore = Math.min(1, state.pointerTypeSet.size / 1); // nonzero is good
  // Keyboard activity
  const keyScore = Math.min(1, state.keyPresses / 6);
  // Focus events (tabbing) suggests real user
  const focusScore = Math.min(1, state.focusEvents / 2);
  // Timing entropy: check variance of inter-event intervals
  let timingScore = 0.5;
  if(state.timestamps.length >= 3) {
	const diffs = [];
	for(let i=1;i<state.timestamps.length;i++) diffs.push(state.timestamps[i]-state.timestamps[i-1]);
	const mean = diffs.reduce((a,b)=>a+b,0)/diffs.length;
	const variance = diffs.reduce((a,b)=>a+Math.pow(b-mean,2),0)/diffs.length;
	// more natural variance -> higher score (not perfectly robust)
	timingScore = Math.tanh(variance/400) ; // scaled sigmoid-like
  }

  const weights = {mouse:0.35, pointer:0.15, key:0.2, focus:0.1, timing:0.2};
  const score = mouseScore*weights.mouse + pointerScore*weights.pointer + keyScore*weights.key + focusScore*weights.focus + timingScore*weights.timing;
  return score;
}

function onBehaviorEvaluated(score){
  const scoreText = `Behavior score: ${score.toFixed(2)} (threshold ${BEHAVIOR_MIN_SCORE})`;
  setStatus(scoreText);
  
  if(score >= BEHAVIOR_MIN_SCORE){
	announceToScreenReader(`Behavior score ${score.toFixed(2)}. Verification passed.`, 'polite');
	playSuccessSound();
	// In production: send a signed token or evidence to server for validation and receive a session token
	// Example: POST /verify-behavior {score, events-hash, sessionId} -> server issues short-lived pass token
	showResult(true, 'Invisible behavioral check passed.');
  } else {
	const failMessage = `Behavior score ${score.toFixed(2)} is below the threshold. Behavioral check could not confidently verify you. Please choose an alternative verification method: Passkey or Text question.`;
	announceToScreenReader(failMessage, 'assertive');
	playErrorSound();
	// If the user selected auto, offer alternatives
	showResult(false, 'Behavioral check could not confidently verify you. Please choose an alternative (Passkey or Text question).');
  }
}

/* ---------- WebAuthn / Passkey (working implementation) ---------- */
const STORAGE_KEY = 'webauthn_credential_id';

// Generate a random challenge (in production, server would generate this)
function generateChallenge() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return array;
}

// Convert ArrayBuffer to base64url
function arrayBufferToBase64url(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
	binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary)
	.replace(/\+/g, '-')
	.replace(/\//g, '_')
	.replace(/=/g, '');
}

// Convert base64url to ArrayBuffer
function base64urlToArrayBuffer(base64url) {
  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
	bytes[i] = binary.charCodeAt(i);
  }
  return bytes.buffer;
}

// Check if WebAuthn is supported (cross-browser compatible)
function isWebAuthnSupported() {
  // Basic WebAuthn support check
  if (!window.PublicKeyCredential || !navigator.credentials) {
	return false;
  }
  
  // Check for platform authenticator availability (may not be available in all browsers)
  try {
	if (typeof PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === 'function') {
	  return true; // Function exists, will check async if needed
	}
	return true; // PublicKeyCredential exists, assume support
  } catch (e) {
	console.warn('WebAuthn availability check failed:', e);
	return false;
  }
}

// Async check for platform authenticator (better browser compatibility)
async function checkPlatformAuthenticatorAvailable() {
  try {
	if (typeof PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === 'function') {
	  return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
	}
	// Fallback: if WebAuthn is supported, assume platform authenticator might be available
	return isWebAuthnSupported();
  } catch (e) {
	console.warn('Platform authenticator check failed:', e);
	return false;
  }
}

// Check if we have a stored credential
function hasStoredCredential() {
  return !!window.safeStorage.getItem(STORAGE_KEY);
}

// Update passkey UI based on state
function updatePasskeyUI() {
  const createBtn = document.getElementById('createPasskey');
  const authBtn = document.getElementById('authenticatePasskey');
  const clearBtn = document.getElementById('clearPasskey');
  const description = document.getElementById('passkeyDescription');
  const status = document.getElementById('passkeyStatus');
  
  if (!isWebAuthnSupported()) {
	createBtn.style.display = 'none';
	authBtn.style.display = 'none';
	clearBtn.style.display = 'none';
	description.textContent = 'WebAuthn is not available in this browser. Please use a modern browser that supports WebAuthn/Passkeys.';
	return;
  }
  
  if (hasStoredCredential()) {
	createBtn.style.display = 'none';
	authBtn.style.display = 'inline-block';
	clearBtn.style.display = 'inline-block';
	description.textContent = 'You have a passkey registered. Authenticate to verify your identity.';
	status.textContent = 'Passkey ready for authentication';
	status.style.display = 'block';
	status.style.color = '#065f46';
  } else {
	createBtn.style.display = 'inline-block';
	authBtn.style.display = 'none';
	clearBtn.style.display = 'none';
	description.textContent = 'Create a passkey to use for verification. This will use your device\'s biometric or security key.';
	status.style.display = 'none';
  }
}

// Create a new passkey (registration)
async function createPasskey() {
  if (!isWebAuthnSupported()) {
	const errorMsg = 'WebAuthn is not available in this browser.';
	setStatus(errorMsg);
	announceToScreenReader(errorMsg, 'assertive');
	showResult(false, errorMsg);
	return;
  }
  
  setStatus('Creating passkey... Please follow your device\'s prompts.');
  announceToScreenReader('Creating passkey. Please follow your device prompts.');
  playInfoSound();
  
  try {
	const challenge = generateChallenge();
	const userId = generateChallenge(); // In production, use a stable user ID
	
	const publicKeyCredentialCreationOptions = {
	  challenge: challenge,
	  rp: {
		name: 'CAPTCHA Demo',
		id: window.location.hostname || 'localhost',
	  },
	  user: {
		id: userId,
		name: 'user@example.com',
		displayName: 'Demo User',
	  },
	  pubKeyCredParams: [
		{ alg: -7, type: 'public-key' }, // ES256
		{ alg: -257, type: 'public-key' }, // RS256
	  ],
	  authenticatorSelection: {
		authenticatorAttachment: 'platform', // Use platform authenticator (biometrics)
		userVerification: 'preferred', // Use 'preferred' for better browser compatibility
	  },
	  timeout: 60000,
	  attestation: 'none',
	};
	
	const credential = await navigator.credentials.create({
	  publicKey: publicKeyCredentialCreationOptions
	});
	
	if (credential) {
	  // Store credential ID for demo (in production, send to server)
	  const credentialId = arrayBufferToBase64url(credential.rawId);
	  window.safeStorage.setItem(STORAGE_KEY, credentialId);
	  
	  setStatus('Passkey created successfully!');
	  announceToScreenReader('Passkey created successfully. You can now authenticate.', 'assertive');
	  updatePasskeyUI();
	  showResult(true, 'Passkey created successfully. You can now authenticate.');
	}
  } catch (err) {
	let errorMsg = 'Failed to create passkey. ';
	if (err.name === 'NotAllowedError') {
	  errorMsg += 'The operation was cancelled or not allowed.';
	} else if (err.name === 'InvalidStateError') {
	  errorMsg += 'A passkey may already exist for this device.';
	} else if (err.name === 'NotSupportedError') {
	  errorMsg += 'WebAuthn is not supported on this device.';
	} else {
	  errorMsg += err.message || 'Unknown error occurred.';
	}
	
	setStatus(errorMsg);
	announceToScreenReader(errorMsg, 'assertive');
	showResult(false, errorMsg);
	console.error('Passkey creation error:', err);
  }
}

// Authenticate with existing passkey
async function authenticatePasskey() {
  if (!isWebAuthnSupported()) {
	const errorMsg = 'WebAuthn is not available in this browser.';
	setStatus(errorMsg);
	announceToScreenReader(errorMsg, 'assertive');
	showResult(false, errorMsg);
	return;
  }
  
  const storedCredentialId = window.safeStorage.getItem(STORAGE_KEY);
  if (!storedCredentialId) {
	const errorMsg = 'No passkey found. Please create one first.';
	setStatus(errorMsg);
	announceToScreenReader(errorMsg, 'assertive');
	showResult(false, errorMsg);
	updatePasskeyUI();
	return;
  }
  
  setStatus('Authenticating with passkey... Please verify your identity.');
  announceToScreenReader('Authenticating with passkey. Please verify your identity using your device.');
  playInfoSound();
  
  try {
	const challenge = generateChallenge();
	const credentialId = base64urlToArrayBuffer(storedCredentialId);
	
	const publicKeyCredentialRequestOptions = {
	  challenge: challenge,
	  timeout: 60000,
	  rpId: window.location.hostname || 'localhost',
	  allowCredentials: [{
		id: credentialId,
		type: 'public-key',
		transports: ['internal', 'usb', 'nfc', 'ble'],
	  }],
	  userVerification: 'preferred', // Use 'preferred' for better browser compatibility
	  extensions: {}
	};
	
	const assertion = await navigator.credentials.get({
	  publicKey: publicKeyCredentialRequestOptions
	});
	
	if (assertion) {
	  // In production, send assertion to server for verification
	  // For demo, we'll just verify it was successful
	  setStatus('Passkey authentication successful!');
	  announceToScreenReader('Passkey authentication successful. Verification passed.', 'assertive');
	  showResult(true, 'Passkey authentication successful. Verification passed.');
	}
  } catch (err) {
	let errorMsg = 'Passkey authentication failed. ';
	if (err.name === 'NotAllowedError') {
	  errorMsg += 'The operation was cancelled or not allowed.';
	} else if (err.name === 'InvalidStateError') {
	  errorMsg += 'The passkey may have been removed.';
	} else if (err.name === 'NotFoundError') {
	  errorMsg += 'No passkey found. Please create one first.';
	} else {
	  errorMsg += err.message || 'Unknown error occurred.';
	}
	
	setStatus(errorMsg);
	announceToScreenReader(errorMsg, 'assertive');
	showResult(false, errorMsg);
	console.error('Passkey authentication error:', err);
	
	// Clear invalid credential
	if (err.name === 'NotFoundError' || err.name === 'InvalidStateError') {
	  window.safeStorage.removeItem(STORAGE_KEY);
	  updatePasskeyUI();
	}
  }
}

// Clear stored passkey
function clearStoredPasskey() {
  window.safeStorage.removeItem(STORAGE_KEY);
  updatePasskeyUI();
  setStatus('Stored passkey cleared. You can create a new one.');
  announceToScreenReader('Stored passkey cleared.');
}

// Initialize passkey flow
async function initializePasskeyFlow() {
  updatePasskeyUI();
  
  if (!isWebAuthnSupported()) {
	const errorMsg = 'WebAuthn is not available in this browser. Please use a modern browser that supports WebAuthn/Passkeys.';
	setStatus(errorMsg);
	announceToScreenReader(errorMsg, 'assertive');
  }
}

/* ---------- Text question flow (accessible) ---------- */
const questions = [
  {q: "Type the color of the sky on a clear day (one word).", a: "blue"},
  {q: "Is fire usually hot or cold? (one word)", a: "hot"},
  {q: "Type the second letter of the word 'apple'.", a: "p"}
];

let activeQuestion = null;

function startTextChallenge(){
  activeQuestion = questions[Math.floor(Math.random()*questions.length)];
  const questionText = document.getElementById('questionText');
  const textAnswer = document.getElementById('textAnswer');
  const textError = document.getElementById('textError');
  const textChallenge = document.getElementById('textChallenge');
  
  questionText.textContent = activeQuestion.q;
  questionText.setAttribute('aria-label', `Question: ${activeQuestion.q}`);
  textAnswer.value = '';
  textAnswer.setAttribute('aria-invalid', 'false');
  textError.classList.add('hidden');
  textError.textContent = '';
  
  textChallenge.classList.remove('hidden');
  textChallenge.setAttribute('aria-hidden','false');
  
  // Focus after a brief delay to ensure screen readers announce the question
  setTimeout(() => {
	textAnswer.focus();
	announceToScreenReader(`Question: ${activeQuestion.q}`);
	playInfoSound();
  }, 100);
}

function showTextError(message) {
  const textError = document.getElementById('textError');
  const textAnswer = document.getElementById('textAnswer');
  
  textError.textContent = message;
  textError.classList.remove('hidden');
  textAnswer.setAttribute('aria-invalid', 'true');
  textAnswer.focus();
  announceToScreenReader(`Error: ${message}`);
  playErrorSound();
}

function clearTextError() {
  const textError = document.getElementById('textError');
  const textAnswer = document.getElementById('textAnswer');
  
  textError.classList.add('hidden');
  textError.textContent = '';
  textAnswer.setAttribute('aria-invalid', 'false');
}

document.getElementById('submitText').addEventListener('click', ()=>{
  const val = document.getElementById('textAnswer').value.trim();
  
  if(!activeQuestion) {
	showTextError('No question is active. Please start a new challenge.');
	return;
  }
  
  if(!val) {
	showTextError('Please enter an answer before submitting.');
	return;
  }
  
  clearTextError();
  
  const ok = val.toLowerCase() === activeQuestion.a.toLowerCase();
  if(ok){
	setStatus('Text question answered correctly.');
	announceToScreenReader('Answer correct. Verification passed.');
	// In production: create a server-side record / short-lived token proving the user passed the accessibility fallback.
	showResult(true, 'Text question passed.');
	
	// Hide the challenge after success
	const textChallenge = document.getElementById('textChallenge');
	textChallenge.classList.add('hidden');
	textChallenge.setAttribute('aria-hidden','true');
  } else {
	setStatus('Incorrect answer. Try another method or try again.');
	showTextError('Incorrect answer. Please try again or choose another verification method.');
	showResult(false, 'Text answer incorrect.');
	
	// Clear the input for retry
	document.getElementById('textAnswer').value = '';
	document.getElementById('textAnswer').focus();
  }
});

document.getElementById('cancelText').addEventListener('click', ()=>{
  const textChallenge = document.getElementById('textChallenge');
  textChallenge.classList.add('hidden');
  textChallenge.setAttribute('aria-hidden','true');
  clearTextError();
  setStatus('Text challenge canceled.');
  announceToScreenReader('Text challenge canceled.');
  playInfoSound();
  
  // Return focus to start button
  document.getElementById('startBtn').focus();
});

// Allow Enter key to submit in text input
document.getElementById('textAnswer').addEventListener('keydown', (e) => {
  if(e.key === 'Enter') {
	e.preventDefault();
	document.getElementById('submitText').click();
  }
});

/* ---------- Wire up start button and passkey demo buttons ---------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  const resultBox = document.getElementById('resultBox');
  resultBox.classList.add('hidden');
  resultBox.setAttribute('aria-hidden','true');
  resultBox.innerHTML = '';
  
  // Clear any previous errors
  const textError = document.getElementById('textError');
  if(textError) {
	textError.classList.add('hidden');
	textError.textContent = '';
  }
  
  setStatus('Starting verification...');
  announceToScreenReader('Starting verification...');
  playInfoSound();
  
  if(selectedMode === 'auto'){
	setStatus('Collecting behavior for a few seconds â€” move your mouse or type a bit if you are using a keyboard.');
	announceToScreenReader('Collecting behavior for 5 seconds. Please interact with the page by moving your mouse or typing.');
	collectBehaviorEvents();
  } else if(selectedMode === 'passkey'){
	// show passkey UI
	const passkeyInfo = document.getElementById('passkeyInfo');
	passkeyInfo.classList.remove('hidden');
	passkeyInfo.setAttribute('aria-hidden','false');
	
	// Initialize passkey flow
	initializePasskeyFlow();
	
	// Focus first available passkey button
	setTimeout(() => {
	  const createBtn = document.getElementById('createPasskey');
	  const authBtn = document.getElementById('authenticatePasskey');
	  if (authBtn && authBtn.style.display !== 'none') {
		authBtn.focus();
	  } else if (createBtn && createBtn.style.display !== 'none') {
		createBtn.focus();
	  }
	}, 100);
  } else if(selectedMode === 'text' || selectedMode === 'keyboard'){
	startTextChallenge();
  }
});

// Wire up passkey buttons
document.getElementById('createPasskey')?.addEventListener('click', () => {
  createPasskey();
});

document.getElementById('authenticatePasskey')?.addEventListener('click', () => {
  authenticatePasskey();
});

document.getElementById('clearPasskey')?.addEventListener('click', () => {
  clearStoredPasskey();
});

// Wire up audio toggle
document.getElementById('audioToggle')?.addEventListener('click', () => {
  toggleAudioAlerts();
});

/* ---------- Result handling ---------- */
function showResult(passed, message){
  const rb = document.getElementById('resultBox');
  rb.classList.remove('hidden');
  rb.setAttribute('aria-hidden','false');
  rb.innerHTML = '';
  
  if(passed){
	const resultHtml = `
	  <div class="success" role="status" aria-live="polite" aria-atomic="true">
		<strong>Verification passed</strong>
		<div style="margin-top:6px">${escapeHtml(message)}</div>
	  </div>
	`;
	rb.innerHTML = resultHtml;
	announceToScreenReader(`Verification passed. ${message}`, 'assertive');
	playSuccessSound();
	// In production: call server to exchange local proof for a session token, set cookie, continue action
	// Example: POST /verify-result {method: 'behavior'|'webauthn'|'text', evidence: {...}} -> returns session token
  } else {
	const resultHtml = `
	  <div class="danger" role="alert" aria-live="assertive" aria-atomic="true">
		<strong>Verification failed</strong>
		<div style="margin-top:6px">${escapeHtml(message)}</div>
	  </div>
	`;
	rb.innerHTML = resultHtml;
	announceToScreenReader(`Verification failed. ${message}`, 'assertive');
	playErrorSound();
	
	// Focus the result for screen reader users
	setTimeout(() => {
	  const alertDiv = rb.querySelector('[role="alert"]');
	  if(alertDiv) {
		alertDiv.setAttribute('tabindex', '-1');
		alertDiv.focus();
	  }
	}, 100);
  }
}

/* ---------- Utilities ---------- */
function setStatus(text){
  const s = document.getElementById('status');
  s.textContent = text;
  s.setAttribute('aria-label', `Status: ${text}`);
}

function escapeHtml(s){ 
  return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); 
}

/* ---------- Initialize ---------- */
updateModeUI();

// Set initial tabindex for mode buttons (roving tabindex pattern)
modeButtons.forEach(btn => {
  btn.setAttribute('tabindex', btn.getAttribute('aria-pressed') === 'true' ? '0' : '-1');
});

// Load audio preferences
loadAudioPreference();

// Initialize passkey flow if in passkey mode
if (selectedMode === 'passkey') {
  initializePasskeyFlow();
}

setStatus('Ready â€” choose a mode and press Start.');
announceToScreenReader('Ready. Choose a verification mode and press Start verification button.');

/* Keyboard accessibility: allow selecting modes with arrow keys when focused */
const rg = document.querySelector('[role="radiogroup"]');
rg.addEventListener('keydown', (e)=>{
  const keys = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End'];
  if(!keys.includes(e.key)) return;
  
  // Only handle if focus is within the radiogroup
  if(!rg.contains(document.activeElement) && !Array.from(modeButtons).includes(document.activeElement)) {
	return;
  }
  
  e.preventDefault();
  const buttons = Array.from(modeButtons);
  const current = buttons.findIndex(b=>b.getAttribute('aria-pressed')==='true');
  let next = current;
  
  if(e.key === 'ArrowRight' || e.key === 'ArrowDown') {
	next = (current + 1) % buttons.length;
  } else if(e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
	next = (current - 1 + buttons.length) % buttons.length;
  } else if(e.key === 'Home') {
	next = 0;
  } else if(e.key === 'End') {
	next = buttons.length - 1;
  }
  
  buttons[next].click();
  buttons[next].focus();
});

// Make mode buttons focusable with tab and improve keyboard navigation
modeButtons.forEach((btn, index) => {
  btn.setAttribute('tabindex', btn.getAttribute('aria-pressed') === 'true' ? '0' : '-1');
  
  btn.addEventListener('focus', () => {
	// Update tabindex for roving tabindex pattern
	modeButtons.forEach(b => b.setAttribute('tabindex', '-1'));
	btn.setAttribute('tabindex', '0');
  });
});
</script>
</body>
</html>
